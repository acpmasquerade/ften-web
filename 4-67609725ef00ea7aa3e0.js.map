{"version":3,"sources":["webpack:///./src/pages/lib/fountain.js","webpack:///./src/pages/lib/sanscript.js","webpack:///./src/pages/lib/literator.js","webpack:///./node_modules/core-js/modules/es6.function.name.js"],"names":["regex","title_page","scene_heading","scene_number","transition","dialogue","parenthetical","action","centered","section","synopsis","note","note_inline","boneyard","page_break","line_break","emphasis","bold_italic_underline","bold_underline","italic_underline","bold_italic","bold","italic","underline","splitter","cleaner","standardizer","whitespacer","tokenize","script","line","match","parts","text","meta","x","xlen","dual","src","replace","lexer","split","i","length","tokens","test","reverse","push","type","trim","toLowerCase","indexOf","undefined","depth","fountain","callback","parse","toks","token","title","output","title_info","html","updateTitleInfo","key","value","join","module","exports","call","this","Sanscript","defaults","skip_sgml","syncope","enableTamilPronounciation","enableTamilCharPositionFixes","enableSanskritVedicAccents","schemes","bengali","vowels","vowel_marks","other_marks","virama","consonants","symbols","other","accent","combo_accent","devanagari","zwj","skip","candra","gujarati","gurmukhi","kannada","malayalam","oriya","tamil","telugu","iast","itrans","hk","slp1","velthuis","wx","romanSchemes","allAlternates","A","I","U","RRi","RRI","LLi","LLI","M","~N","ch","Ch","~n","v","Sh","kSh","j~n","OM","\\_","\\_H","\\'M","\\_M",".a","|","||","z","cache","isRomanScheme","name","hasOwnProperty","addBrahmicScheme","scheme","addRomanScheme","slice","cheapCopy","copy","kolkata","schemeNames","itrans_dravidian","t","data","from","to","options","map","cachedOptions","hasPriorState","alternates","fromScheme","letters","tokenLengths","marks","toScheme","group","fromGroup","toGroup","F","T","alts","numAlts","j","fromRoman","maxTokenLength","Math","max","apply","toRoman","makeMap","alldata","tempLetter","tempMark","L","buf","dataLength","hadConsonant","optSkipSGML","optSyncope","tokenBuffer","skippingSGML","skippingTrans","toggledTrans","charAt","difference","substr","transliterateRoman","temp","danglingHash","hadRomanConsonant","transliterateBrahmic","parser","require","transliterate","input","transform","dialog","dictionary","exclude","word","literate","done","result","toString","console","log","dP","__webpack_require__","f","FProto","Function","prototype","nameRE","configurable","get","e"],"mappings":"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","file":"4-67609725ef00ea7aa3e0.js","sourcesContent":["// fountain-js 0.1.10\n// http://www.opensource.org/licenses/mit-license.php\n// Copyright (c) 2012 Matt Daly\n\n/* eslint-disable */\n\n(function() {\n   \n  var regex = {\n    title_page: /^((?:title|credit|author[s]?|source|notes|draft date|date|contact|copyright)\\:)/gim,\n\n    scene_heading: /^((?:\\*{0,3}_?)?(?:(?:int|ext|est|i\\/e)[. ]).+)|^(?:\\.(?!\\.+))(.+)/i,\n    scene_number: /( *#(.+)# *)/,\n\n    transition: /^((?:FADE (?:TO BLACK|OUT)|CUT TO BLACK)\\.|.+ TO\\:)|^(?:> *)(.+)/,\n    \n    dialogue: /^([A-Z*_]+[0-9A-Z (._\\-')]*)(\\^?)?(?:\\n(?!\\n+))([\\s\\S]+)/,\n    parenthetical: /^(\\(.+\\))$/,\n\n    action: /^(.+)/g,\n    centered: /^(?:> *)(.+)(?: *<)(\\n.+)*/g,\n        \n    section: /^(#+)(?: *)(.*)/,\n    synopsis: /^(?:\\=(?!\\=+) *)(.*)/,\n\n    note: /^(?:\\[{2}(?!\\[+))(.+)(?:\\]{2}(?!\\[+))$/,\n    note_inline: /(?:\\[{2}(?!\\[+))([\\s\\S]+?)(?:\\]{2}(?!\\[+))/g,\n    boneyard: /(^\\/\\*|^\\*\\/)$/g,\n\n    page_break: /^\\={3,}$/,\n    line_break: /^ {2}$/,\n\n    emphasis: /(_|\\*{1,3}|_\\*{1,3}|\\*{1,3}_)(.+)(_|\\*{1,3}|_\\*{1,3}|\\*{1,3}_)/g,\n    bold_italic_underline: /(_{1}\\*{3}(?=.+\\*{3}_{1})|\\*{3}_{1}(?=.+_{1}\\*{3}))(.+?)(\\*{3}_{1}|_{1}\\*{3})/g,\n    bold_underline: /(_{1}\\*{2}(?=.+\\*{2}_{1})|\\*{2}_{1}(?=.+_{1}\\*{2}))(.+?)(\\*{2}_{1}|_{1}\\*{2})/g,\n    italic_underline: /(?:_{1}\\*{1}(?=.+\\*{1}_{1})|\\*{1}_{1}(?=.+_{1}\\*{1}))(.+?)(\\*{1}_{1}|_{1}\\*{1})/g,\n    bold_italic: /(\\*{3}(?=.+\\*{3}))(.+?)(\\*{3})/g,\n    bold: /(\\*{2}(?=.+\\*{2}))(.+?)(\\*{2})/g,\n    italic: /(\\*{1}(?=.+\\*{1}))(.+?)(\\*{1})/g,\n    underline: /(_{1}(?=.+_{1}))(.+?)(_{1})/g,\n\n    splitter: /\\n{2,}/g,\n    cleaner: /^\\n+|\\n+$/,\n    standardizer: /\\r\\n|\\r/g,\n    whitespacer: /^\\t+|^ {3,}/gm\n  };\n\n  var lexer = function (script) {\n    return script.replace(regex.boneyard, '\\n$1\\n')\n                 .replace(regex.standardizer, '\\n')\n                 .replace(regex.cleaner, '')\n                 .replace(regex.whitespacer, '');\n  };\n     \n  var tokenize = function (script) {\n    var src    = lexer(script).split(regex.splitter)\n      , i      = src.length, line, match, parts, text, meta, x, xlen, dual\n      , tokens = [];\n\n    while (i--) {\n      line = src[i];\n      \n      // title page\n      if (regex.title_page.test(line)) {\n        match = line.replace(regex.title_page, '\\n$1').split(regex.splitter).reverse();\n        for (x = 0, xlen = match.length; x < xlen; x++) {\n          parts = match[x].replace(regex.cleaner, '').split(/\\:\\n*/);\n          tokens.push({ type: parts[0].trim().toLowerCase().replace(' ', '_'), text: parts[1].trim() });\n        }\n        continue;\n      }\n\n      // scene headings\n      if (match = line.match(regex.scene_heading)) {\n        text = match[1] || match[2];\n\n        if (text.indexOf('  ') !== text.length - 2) {\n          if (meta = text.match(regex.scene_number)) {\n            meta = meta[2];\n            text = text.replace(regex.scene_number, '');\n          }\n          tokens.push({ type: 'scene_heading', text: text, scene_number: meta || undefined });\n        }\n        continue;\n      }\n\n      // centered\n      if (match = line.match(regex.centered)) {\n        tokens.push({ type: 'centered', text: match[0].replace(/>|</g, '') });\n        continue;\n      }\n\n      // transitions\n      if (match = line.match(regex.transition)) {\n        tokens.push({ type: 'transition', text: match[1] || match[2] });\n        continue;\n      }\n    \n      // dialogue blocks - characters, parentheticals and dialogue\n      if (match = line.match(regex.dialogue)) {\n        if (match[1].indexOf('  ') !== match[1].length - 2) {\n          // we're iterating from the bottom up, so we need to push these backwards\n          if (match[2]) {\n            tokens.push({ type: 'dual_dialogue_end' });\n          }\n\n          tokens.push({ type: 'dialogue_end' });\n\n          parts = match[3].split(/(\\(.+\\))(?:\\n+)/).reverse();\n\n          for (x = 0, xlen = parts.length; x < xlen; x++) {\t\n            text = parts[x];\n\n            if (text.length > 0) {               \n              tokens.push({ type: regex.parenthetical.test(text) ? 'parenthetical' : 'dialogue', text: text });\n            }\n          }\n\n          tokens.push({ type: 'character', text: match[1].trim() });\n          tokens.push({ type: 'dialogue_begin', dual: match[2] ? 'right' : dual ? 'left' : undefined });\n\n          if (dual) {\n            tokens.push({ type: 'dual_dialogue_begin' });\n          }\n\n          dual = match[2] ? true : false;\n          continue;\n        }\n      }\n      \n      // section\n      if (match = line.match(regex.section)) {\n        tokens.push({ type: 'section', text: match[2], depth: match[1].length });\n        continue;\n      }\n      \n      // synopsis\n      if (match = line.match(regex.synopsis)) {\n        tokens.push({ type: 'synopsis', text: match[1] });\n        continue;\n      }\n\n      // notes\n      if (match = line.match(regex.note)) {\n        tokens.push({ type: 'note', text: match[1]});\n        continue;\n      }      \n\n      // boneyard\n      if (match = line.match(regex.boneyard)) {\n        tokens.push({ type: match[0][0] === '/' ? 'boneyard_begin' : 'boneyard_end' });\n        continue;\n      }      \n\n      // page breaks\n      if (regex.page_break.test(line)) {\n        tokens.push({ type: 'page_break' });\n        continue;\n      }\n      \n      // line breaks\n      if (regex.line_break.test(line)) {\n        tokens.push({ type: 'line_break' });\n        continue;\n      }\n\n      tokens.push({ type: 'action', text: line });\n    }\n    return tokens;\n  };\n\n  var inline = {\n    note: '<!-- $1 -->',\n\n    line_break: '<br />',\n\n    bold_italic_underline: '<span class=\\\"bold italic underline\\\">$2</span>',\n    bold_underline: '<span class=\\\"bold underline\\\">$2</span>',\n    italic_underline: '<span class=\\\"italic underline\\\">$2</span>',\n    bold_italic: '<span class=\\\"bold italic\\\">$2</span>',\n    bold: '<span class=\\\"bold\\\">$2</span>',\n    italic: '<span class=\\\"italic\\\">$2</span>',\n    underline: '<span class=\\\"underline\\\">$2</span>'\n  };\n\n  inline.lexer = function (s) {\n    if (!s) {\n      return;\n    }  \n\n    var styles = [ 'underline', 'italic', 'bold', 'bold_italic', 'italic_underline', 'bold_underline', 'bold_italic_underline' ]\n           , i = styles.length, style, match;\n\n    s = s.replace(regex.note_inline, inline.note).replace(/\\\\\\*/g, '[star]').replace(/\\\\_/g, '[underline]').replace(/\\n/g, inline.line_break);\n\n   // if (regex.emphasis.test(s)) {                         // this was causing only every other occurence of an emphasis syntax to be parsed\n      while (i--) {\n        style = styles[i];\n        match = regex[style];\n   \n        if (match.test(s)) {\n          s = s.replace(match, inline[style]);\n        }\n      }\n   // }\n\n    return s.replace(/\\[star\\]/g, '*').replace(/\\[underline\\]/g, '_').trim();\n  };\n\n  var parse = function (script, toks, callback) {\n    if (callback === undefined && typeof toks === 'function') {\n      callback = toks;\n      toks = undefined;\n    }\n\n      \n    var tokens = tokenize(script)\n      , i      = tokens.length, token, title_info = {}\n      , title, title_page = [], html = [], output;\n\n    function updateTitleInfo(key, value) {\n      title_info[key] = value;\n    }\n\n    while (i--) {\n      token = tokens[i];\n      // token.text = inline.lexer(token.text);\n\n      switch (token.type) {\n        case 'title': \n          updateTitleInfo(token.type, token.text);\n          title_page.push('<h1>' + token.text + '</h1>'); \n          title = token.text.replace('<br />', ' ').replace(/<(?:.|\\n)*?>/g, ''); \n          break;\n        case 'credit': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"credit\\\">' + token.text + '</p>'); break;\n        case 'author': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"authors\\\">' + token.text + '</p>'); break;\n        case 'authors': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"authors\\\">' + token.text + '</p>'); break;\n        case 'source': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"source\\\">' + token.text + '</p>'); break;\n        case 'notes': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"notes\\\">' + token.text + '</p>'); break;\n        case 'draft_date': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"draft-date\\\">' + token.text + '</p>'); break;\n        case 'date': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"date\\\">' + token.text + '</p>'); break;\n        case 'contact': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"contact\\\">' + token.text + '</p>'); break;\n        case 'copyright': updateTitleInfo(token.type, token.text);title_page.push('<p class=\\\"copyright\\\">' + token.text + '</p>'); break;\n\n        case 'scene_heading': html.push('<h3' + (token.scene_number ? ' id=\\\"' + token.scene_number + '\\\">' : '>') + token.text + '</h3>'); break;\n        case 'transition': html.push('<h2>' + token.text + '</h2>'); break;\n\n        case 'dual_dialogue_begin': html.push('<div class=\\\"dual-dialogue\\\">'); break;\n        case 'dialogue_begin': html.push('<div class=\\\"dialogue' + (token.dual ? ' ' + token.dual : '') + '\\\">'); break;\n        case 'character': html.push('<h4>' + token.text + '</h4>'); break;\n        case 'parenthetical': html.push('<p class=\\\"parenthetical\\\">' + token.text + '</p>'); break;\n        case 'dialogue': html.push('<p>' + token.text + '</p>'); break;\n        case 'dialogue_end': html.push('</div> '); break;\n        case 'dual_dialogue_end': html.push('</div> '); break;\n\n        case 'section': html.push('<p class=\\\"section\\\" data-depth=\\\"' + token.depth + '\\\">' + token.text + '</p>'); break;\n        case 'synopsis': html.push('<p class=\\\"synopsis\\\">' + token.text + '</p>'); break;\n\n        case 'note': html.push('<!-- ' + token.text + '-->'); break;\n        case 'boneyard_begin': html.push('<!-- '); break;\n        case 'boneyard_end': html.push(' -->'); break;\n\n        case 'action': html.push('<p>' + token.text + '</p>'); break;\n        case 'centered': html.push('<p class=\\\"centered\\\">' + token.text + '</p>'); break;\n        \n        case 'page_break': html.push('<hr />'); break;\n        case 'line_break': html.push('<br />'); break;\n      }\n    }\n\n    output = { title: title, title_info: title_info, html: { title_page: title_page.join(''), script: html.join('') }, tokens: toks ? tokens.reverse() : undefined };\n\n\n    if (typeof callback === 'function') {\n      return callback(output);\n    }\n\n    return output;\n  };\n\n  var fountain = function (script, callback) {\n    return fountain.parse(script, callback);\n  };\n    \n  fountain.parse = function (script, tokens, callback) {\n    return parse(script, tokens, callback);\n  };\n\n  fountain.regex = regex;\n\n  if (typeof module !== 'undefined') {\n    module.exports = fountain;\n  } else {\n    this.fountain = fountain;\n  }  \n}).call(this);\n","/**\n * Created by vikram on 9/11/2015.\n */\n \n    var Sanscript= function(){};\n\n    Sanscript.defaults = {\n        skip_sgml: false,\n        syncope: false,\n        enableTamilPronounciation: true,\n        enableTamilCharPositionFixes: true,\n        enableSanskritVedicAccents : true,\n    };\n\n    /* Schemes\n     * =======\n     * Schemes are of two kinds: \"Brahmic\" and \"roman.\" \"Brahmic\" schemes\n     * describe abugida scripts found in India. \"Roman\" schemes describe\n     * manufactured alphabets that are meant to describe or encode Brahmi\n     * scripts. Abugidas and alphabets are processed by separate algorithms\n     * because of the unique difficulties involved with each.\n     *\n     * Brahmic consonants are stated without a virama. Roman consonants are\n     * stated without the vowel 'a'.\n     *\n     * (Since \"abugida\" is not a well-known term, Sanscript uses \"Brahmic\"\n     * and \"roman\" for clarity.)\n     */\n    var schemes = Sanscript.schemes = {\n\n            /* Bengali\n             * -------\n             * 'va' and 'ba' are both rendered as ব.\n             */\n            bengali: {\n                vowels: 'অ আ ই ঈ উ ঊ ঋ ৠ ঌ ৡ  এ ঐ  ও ঔ'.split(' '),\n                vowel_marks: 'া ি ী ু ূ ৃ ৄ ৢ ৣ  ে ৈ  ো ৌ'.split(' '),\n                other_marks: 'ং ঃ ঁ'.split(' '),\n                virama: ['্'],\n                consonants: 'ক খ গ ঘ ঙ চ ছ জ ঝ ঞ ট ঠ ড ঢ ণ ত থ দ ধ ন প ফ ব ভ ম য র ল ব শ ষ স হ ळ ক্ষ জ্ঞ'.split(' '),\n                symbols: '০ ১ ২ ৩ ৪ ৫ ৬ ৭ ৮ ৯ ॐ ঽ । ॥'.split(' '),\n                other: '    ড ঢ  য '.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Devanagari\n             * ----------\n             * The most comprehensive and unambiguous Brahmic script listed.\n             */\n            devanagari: {\n                // \"Independent\" forms of the vowels. These are used whenever the\n                // vowel does not immediately follow a consonant.\n                vowels: 'अ आ इ ई उ ऊ ऋ ॠ ऌ ॡ ऎ ए ऐ ऒ ओ औ'.split(' '),\n\n                // \"Dependent\" forms of the vowels. These are used whenever the\n                // vowel immediately follows a consonant. If a letter is not\n                // listed in `vowels`, it should not be listed here.\n                vowel_marks: 'ा ि ी ु ू ृ ॄ ॢ ॣ ॆ े ै ॊ ो ौ'.split(' '),\n\n                // Miscellaneous marks, all of which are used in Sanskrit.\n                other_marks: 'ं ः ँ'.split(' '),\n\n                // In syllabic scripts like Devanagari, consonants have an inherent\n                // vowel that must be suppressed explicitly. We do so by putting a\n                // virama after the consonant.\n                virama: ['्'],\n\n                // Various Sanskrit consonants and consonant clusters. Every token\n                // here has an explicit vowel. Thus \"क\" is \"ka\" instead of \"k\".\n                consonants: 'क ख ग घ ङ च छ ज झ ञ ट ठ ड ढ ण त थ द ध न प फ ब भ म य र ल व श ष स ह ळ क्ष ज्ञ'.split(' '),\n\n                // Numbers and punctuation\n                symbols: '० १ २ ३ ४ ५ ६ ७ ८ ९ ॐ ऽ । ॥'.split(' '),\n\n                // Zero-width joiner. This is used to separate a consonant cluster\n                // and avoid a complex ligature.\n                zwj: ['\\u200D'],\n\n                // Dummy consonant. This is used in ITRANS to prevert certain types\n                // of parser ambiguity. Thus \"barau\" -> बरौ but \"bara_u\" -> बरउ.\n                skip: [''],\n\n                // Vedic accent. Udatta and anudatta.\n                accent: ['\\u0951', '\\u0952'],\n\n                // Accent combined with anusvara and and visarga. For compatibility\n                // with ITRANS, which allows the reverse of these four.\n                combo_accent: 'ः॑ ः॒ ं॑ ं॒'.split(' '),\n\n                candra: ['ॅ'],\n\n                // Non-Sanskrit consonants\n                other: 'क़ ख़ ग़ ज़ ड़ ढ़ फ़ य़ ऱ'.split(' ')\n            },\n\n            /* Gujarati\n             * --------\n             * Sanskrit-complete.\n             */\n            gujarati: {\n                vowels: 'અ આ ઇ ઈ ઉ ઊ ઋ ૠ ઌ ૡ  એ ઐ  ઓ ઔ'.split(' '),\n                vowel_marks: 'ા િ ી ુ ૂ ૃ ૄ ૢ ૣ  ે ૈ  ો ૌ'.split(' '),\n                other_marks: 'ં ઃ ઁ'.split(' '),\n                virama: ['્'],\n                consonants: 'ક ખ ગ ઘ ઙ ચ છ જ ઝ ઞ ટ ઠ ડ ઢ ણ ત થ દ ધ ન પ ફ બ ભ મ ય ર લ વ શ ષ સ હ ળ ક્ષ જ્ઞ'.split(' '),\n                symbols: '૦ ૧ ૨ ૩ ૪ ૫ ૬ ૭ ૮ ૯ ૐ ઽ . ..'.split(' '),\n                candra: ['ૅ'],\n                skip: [''],\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"],\n                other: 'ક ખ ગ જ ડ ઢ ફ ય ર'.split(' ')\n            },\n\n            /* Gurmukhi\n             * --------\n             * Missing R/RR/lR/lRR\n             */\n            gurmukhi: {\n                vowels: 'ਅ ਆ ਇ ਈ ਉ ਊ      ਏ ਐ  ਓ ਔ'.split(' '),\n                vowel_marks: 'ਾ ਿ ੀ ੁ ੂ      ੇ ੈ  ੋ ੌ'.split(' '),\n                other_marks: 'ਂ ਃ ਁ'.split(' '),\n                virama: ['੍'],\n                consonants: 'ਕ ਖ ਗ ਘ ਙ ਚ ਛ ਜ ਝ ਞ ਟ ਠ ਡ ਢ ਣ ਤ ਥ ਦ ਧ ਨ ਪ ਫ ਬ ਭ ਮ ਯ ਰ ਲ ਵ ਸ਼ ਸ਼ ਸ ਹ ਲ਼ ਕ੍ਸ਼ ਜ੍ਞ'.split(' '),\n                symbols: '੦ ੧ ੨ ੩ ੪ ੫ ੬ ੭ ੮ ੯ ॐ ऽ । ॥'.split(' '),\n                other: ' ਖ ਗ ਜ ਡ  ਫ  '.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Kannada\n             * -------\n             * Sanskrit-complete.\n             */\n            kannada: {\n                vowels: 'ಅ ಆ ಇ ಈ ಉ ಊ ಋ ೠ ಌ ೡ ಎ ಏ ಐ ಒ ಓ ಔ'.split(' '),\n                vowel_marks: 'ಾ ಿ ೀ ು ೂ ೃ ೄ ೢ ೣ ೆ ೇ ೈ ೊ ೋ ೌ'.split(' '),\n                other_marks: 'ಂ ಃ ँ'.split(' '),\n                virama: ['್'],\n                consonants: 'ಕ ಖ ಗ ಘ ಙ ಚ ಛ ಜ ಝ ಞ ಟ ಠ ಡ ಢ ಣ ತ ಥ ದ ಧ ನ ಪ ಫ ಬ ಭ ಮ ಯ ರ ಲ ವ ಶ ಷ ಸ ಹ ಳ ಕ್ಷ ಜ್ಞ'.split(' '),\n                symbols: '೦ ೧ ೨ ೩ ೪ ೫ ೬ ೭ ೮ ೯ ಓಂ ಽ । ॥'.split(' '),\n                other: '      ಫ  ಱ'.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Malayalam\n             * ---------\n             * Sanskrit-complete.\n             */\n            malayalam: {\n                vowels: 'അ ആ ഇ ഈ ഉ ഊ ഋ ൠ ഌ ൡ എ ഏ ഐ ഒ ഓ ഔ'.split(' '),\n                vowel_marks: 'ാ ി ീ ു ൂ ൃ ൄ ൢ ൣ െ േ ൈ ൊ ോ ൌ'.split(' '),\n                other_marks: 'ം ഃ ँ'.split(' '),\n                virama: ['്'],\n                consonants: 'ക ഖ ഗ ഘ ങ ച ഛ ജ ഝ ഞ ട ഠ ഡ ഢ ണ ത ഥ ദ ധ ന പ ഫ ബ ഭ മ യ ര ല വ ശ ഷ സ ഹ ള ക്ഷ ജ്ഞ'.split(' '),\n                symbols: '൦ ൧ ൨ ൩ ൪ ൫ ൬ ൭ ൮ ൯ ഓം ഽ । ॥'.split(' '),\n                other: '        റ'.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Oriya\n             * -----\n             * Sanskrit-complete.\n             */\n            oriya: {\n                vowels: 'ଅ ଆ ଇ ଈ ଉ ଊ ଋ ୠ ଌ ୡ  ଏ ଐ  ଓ ଔ'.split(' '),\n                vowel_marks: 'ା ି ୀ ୁ ୂ ୃ ୄ ୢ ୣ  େ ୈ  ୋ ୌ'.split(' '),\n                other_marks: 'ଂ ଃ ଁ'.split(' '),\n                virama: ['୍'],\n                consonants: 'କ ଖ ଗ ଘ ଙ ଚ ଛ ଜ ଝ ଞ ଟ ଠ ଡ ଢ ଣ ତ ଥ ଦ ଧ ନ ପ ଫ ବ ଭ ମ ଯ ର ଲ ଵ ଶ ଷ ସ ହ ଳ କ୍ଷ ଜ୍ଞ'.split(' '),\n                symbols: '୦ ୧ ୨ ୩ ୪ ୫ ୬ ୭ ୮ ୯ ଓଂ ଽ । ॥'.split(' '),\n                other: '    ଡ ଢ  ଯ '.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Tamil\n             * -----\n             * Missing R/RR/lR/lRR vowel marks and voice/aspiration distinctions.\n             * The most incomplete of the Sanskrit schemes here.\n             */\n            tamil: {\n                vowels: 'அ ஆ இ ஈ உ ஊ ருʼ ரூʼ லுʼ லூʼ எ ஏ ஐ ஒ ஓ ஔ'.split(' '),\n                vowel_marks: 'ா ி ீ ு ூ ருʼ ரூʼ லுʼ லூʼ ெ ே ை ொ ோ ௌ'.split(' '),\n                other_marks: 'ம்’ : '.split(' '),\n                virama: ['்'],\n                consonants: 'க க² க³ க⁴ ங ச ச² ஜ ச ஞ ட ட² ட³ ட⁴ ண த த² த³ த⁴ ந ப ப² ப³ ப⁴ ம ய ர ல வ ஶ ஷ ஸ ஹ ள க்ஷ ஜ்ஞ'.split(' '),\n                symbols: '0 1 2 3 4 5 6 7 8 9 ௐ ऽ । ॥'.split(' '),\n                other: '        ற'.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* Telugu\n             * ------\n             * Sanskrit-complete.\n             */\n            telugu: {\n                vowels: 'అ ఆ ఇ ఈ ఉ ఊ ఋ ౠ ఌ ౡ ఎ ఏ ఐ ఒ ఓ ఔ'.split(' '),\n                vowel_marks: 'ా ి ీ ు ూ ృ ౄ ౢ ౣ ె ే ై ొ ో ౌ'.split(' '),\n                other_marks: 'ం ః ఁ'.split(' '),\n                virama: ['్'],\n                consonants: 'క ఖ గ ఘ ఙ చ ఛ జ ఝ ఞ ట ఠ డ ఢ ణ త థ ద ధ న ప ఫ బ భ మ య ర ల వ శ ష స హ ళ క్ష జ్ఞ'.split(' '),\n                symbols: '౦ ౧ ౨ ౩ ౪ ౫ ౬ ౭ ౮ ౯ ఓం ఽ . ..'.split(' '),\n                other: '        ఱ'.split(' '),\n                accent: [\"\", \"\"],\n                combo_accent: [\"\", \"\", \"\", \"\"]\n            },\n\n            /* International Alphabet of Sanskrit Transliteration\n             * --------------------------------------------------\n             * The most \"professional\" Sanskrit romanization scheme.\n             */\n            iast: {\n                vowels: 'a ā i ī u ū ṛ ṝ ḷ ḹ  e ai o au'.split(' '),\n                other_marks: ['ṃ', 'ḥ', '~'],\n                virama: [''],\n                consonants: 'k kh g gh ṅ c ch j jh ñ ṭ ṭh ḍ ḍh ṇ t th d dh n p ph b bh m y r l v ś ṣ s h ḻ kṣ jñ'.split(' '),\n                symbols: \"0 1 2 3 4 5 6 7 8 9 oṃ ' । ॥\".split(' ')\n            },\n\n            /* ITRANS\n             * ------\n             * One of the first romanization schemes -- and one of the most\n             * complicated. For alternate forms, see the \"allAlternates\" variable\n             * below.\n             *\n             * '_' is a \"null\" letter, which allows adjacent vowels.\n             */\n            itrans: {\n                vowels: 'a A i I u U RRi RRI LLi LLI e E ai o O au'.split(' '),\n                other_marks: ['M', 'H', '.N'],\n                virama: [''],\n                consonants: 'k kh g gh ~N ch Ch j jh ~n T Th D Dh N t th d dh n p ph b bh m y r l v sh Sh s h L kSh j~n'.split(' '),\n                symbols: '0 1 2 3 4 5 6 7 8 9 OM .a . ..'.split(' '),\n                candra: ['.c'],\n                zwj: ['{}'],\n                skip: '_',\n                accent: [\"\\\\'\", \"\\\\_\"],\n                combo_accent: \"\\\\'H \\\\_H \\\\'M \\\\_M\".split(' '),\n                other: 'q K G z .D .Dh f Y R'.split(' ')\n            },\n\n            /* Harvard-Kyoto\n             * -------------\n             * A simple 1:1 mapping.\n             */\n            hk: {\n                vowels: 'a A i I u U R RR lR lRR  e ai  o au'.split(' '),\n                other_marks: 'M H ~'.split(' '),\n                virama: [''],\n                consonants: 'k kh g gh G c ch j jh J T Th D Dh N t th d dh n p ph b bh m y r l v z S s h L kS jJ'.split(' '),\n                symbols: \"0 1 2 3 4 5 6 7 8 9 OM ' | ||\".split(' ')\n            },\n\n            /* National Library at Kolkata\n             * ---------------------------\n             * Apart from using \"ē\" and \"ō\" instead of \"e\" and \"o\", this scheme is\n             * identical to IAST. ṝ, ḷ, and ḹ are not part of the scheme proper.\n             *\n             * This is defined further below.\n             */\n\n            /* Sanskrit Library Phonetic Basic\n             * -------------------------------\n             * With one ASCII letter per phoneme, this is the tersest transliteration\n             * scheme in use today and is especially suited to computer processing.\n             */\n            slp1: {\n                vowels: 'a A i I u U f F x X  e E  o O'.split(' '),\n                other_marks: 'M H ~'.split(' '),\n                virama: [''],\n                consonants: 'k K g G N c C j J Y w W q Q R t T d D n p P b B m y r l v S z s h L kz jY'.split(' '),\n                symbols: \"0 1 2 3 4 5 6 7 8 9 oM ' . ..\".split(' ')\n            },\n\n            /* Velthuis\n             * --------\n             * A case-insensitive Sanskrit encoding.\n             */\n            velthuis: {\n                vowels: 'a aa i ii u uu .r .rr .li .ll  e ai  o au'.split(' '),\n                other_marks: '.m .h '.split(' '),\n                virama: [''],\n                consonants: 'k kh g gh \"n c ch j jh ~n .t .th .d .d .n t th d dh n p ph b bh m y r l v ~s .s s h L k.s j~n'.split(' '),\n                symbols: \"0 1 2 3 4 5 6 7 8 9 o.m ' | ||\".split(' ')\n            },\n\n            /* WX\n             * --\n             * As terse as SLP1.\n             */\n            wx: {\n                vowels: 'a A i I u U q Q L   e E  o O'.split(' '),\n                other_marks: 'M H z'.split(' '),\n                virama: [''],\n                consonants: 'k K g G f c C j J F t T d D N w W x X n p P b B m y r l v S R s h  kR jF'.split(' '),\n                symbols: \"0 1 2 3 4 5 6 7 8 9 oM ' | ||\".split(' ')\n            }\n        },\n\n    // Set of names of schemes\n        romanSchemes = {},\n\n    // Map of alternate encodings.\n        allAlternates = {\n            itrans: {\n                A: ['aa'],\n                I: ['ii', 'ee'],\n                U: ['uu', 'oo'],\n                RRi: ['R^i'],\n                RRI: ['R^I'],\n                LLi: ['L^i'],\n                LLI: ['L^I'],\n                M: ['.m', '.n'],\n                '~N': ['N^'],\n                ch: ['c'],\n                Ch: ['C', 'chh'],\n                '~n': ['JN'],\n                v: ['w'],\n                Sh: ['S', 'shh'],\n                kSh: ['kS', 'x'],\n                'j~n': ['GY', 'dny'],\n                OM: ['AUM'],\n                \"\\\\_\": [\"\\\\`\"],\n                \"\\\\_H\": [\"\\\\`H\"],\n                \"\\\\'M\": [\"\\\\'.m\", \"\\\\'.n\"],\n                \"\\\\_M\": \"\\\\_.m \\\\_.n \\\\`M \\\\`.m \\\\`.n\".split(' '),\n                \".a\": ['~'],\n                '|': ['.'],\n                '||': ['..'],\n                z: ['J']\n            }\n        },\n\n    // object cache\n        cache = {};\n\n    /**\n     * Check whether the given scheme encodes romanized Sanskrit.\n     *\n     * @param name  the scheme name\n     * @return      boolean\n     */\n    Sanscript.isRomanScheme = function(name) {\n        return romanSchemes.hasOwnProperty(name);\n    };\n\n    /**\n     * Add a Brahmic scheme to Sanscript.\n     *\n     * Schemes are of two types: \"Brahmic\" and \"roman\". Brahmic consonants\n     * have an inherent vowel sound, but roman consonants do not. This is the\n     * main difference between these two types of scheme.\n     *\n     * A scheme definition is an object (\"{}\") that maps a group name to a\n     * list of characters. For illustration, see the \"devanagari\" scheme at\n     * the top of this file.\n     *\n     * You can use whatever group names you like, but for the best results,\n     * you should use the same group names that Sanscript does.\n     *\n     * @param name    the scheme name\n     * @param scheme  the scheme data itself. This should be constructed as\n     *                described above.\n     */\n    Sanscript.addBrahmicScheme = function(name, scheme) {\n        Sanscript.schemes[name] = scheme;\n    };\n\n    /**\n     * Add a roman scheme to Sanscript.\n     *\n     * See the comments on Sanscript.addBrahmicScheme. The \"vowel_marks\" field\n     * can be omitted.\n     *\n     * @param name    the scheme name\n     * @param scheme  the scheme data itself\n     */\n    Sanscript.addRomanScheme = function(name, scheme) {\n        if (!('vowel_marks' in scheme)) {\n            scheme.vowel_marks = scheme.vowels.slice(1);\n        }\n        Sanscript.schemes[name] = scheme;\n        romanSchemes[name] = true;\n    };\n\n    /**\n     * Create a deep copy of an object, for certain kinds of objects.\n     *\n     * @param scheme  the scheme to copy\n     * @return        the copy\n     */\n    var cheapCopy = function(scheme) {\n        var copy = {};\n        for (var key in scheme) {\n            if (!scheme.hasOwnProperty(key)) {\n                continue;\n            }\n            copy[key] = scheme[key].slice(0);\n        }\n        return copy;\n    };\n\n    // Set up various schemes\n    (function() {\n        // Set up roman schemes\n        var kolkata = schemes.kolkata = cheapCopy(schemes.iast),\n            schemeNames = 'iast itrans hk kolkata slp1 velthuis wx'.split(' ');\n        kolkata.vowels = 'a ā i ī u ū ṛ ṝ ḷ ḹ e ē ai o ō au'.split(' ');\n\n        // These schemes already belong to Sanscript.schemes. But by adding\n        // them again with `addRomanScheme`, we automatically build up\n        // `romanSchemes` and define a `vowel_marks` field for each one.\n        for (var i = 0, name; (name = schemeNames[i]); i++) {\n            Sanscript.addRomanScheme(name, schemes[name]);\n        }\n\n        // ITRANS variant, which supports Dravidian short 'e' and 'o'.\n        var itrans_dravidian = cheapCopy(schemes.itrans);\n        itrans_dravidian.vowels = 'a A i I u U Ri RRI LLi LLi e E ai o O au'.split(' ');\n        itrans_dravidian.vowel_marks = itrans_dravidian.vowels.slice(1);\n        allAlternates.itrans_dravidian = allAlternates.itrans;\n        Sanscript.addRomanScheme('itrans_dravidian', itrans_dravidian);\n    }());\n\n    /**\n     * Create a map from every character in `from` to its partner in `to`.\n     * Also, store any \"marks\" that `from` might have.\n     *\n     * @param from     input scheme\n     * @param to       output scheme\n     * @param options  scheme options\n     */\n    var makeMap = function(from, to, options) {\n        var alternates = allAlternates[from] || {},\n            consonants = {},\n            fromScheme = Sanscript.schemes[from],\n            letters = {},\n            tokenLengths = [],\n            marks = {},\n            toScheme = Sanscript.schemes[to];\n\n        for (var group in fromScheme) {\n            if (!fromScheme.hasOwnProperty(group)) {\n                continue;\n            }\n            var fromGroup = fromScheme[group],\n                toGroup = toScheme[group];\n            if (toGroup === undefined) {\n                continue;\n            }\n            for (var i = 0; i < fromGroup.length; i++) {\n                var F = fromGroup[i],\n                    T = toGroup[i],\n                    alts = alternates[F] || [],\n                    numAlts = alts.length,\n                    j = 0;\n\n                tokenLengths.push(F.length);\n                for (j = 0; j < numAlts; j++) {\n                    tokenLengths.push(alts[j].length);\n                }\n\n                if (group === 'vowel_marks' || group === 'virama') {\n                    marks[F] = T;\n                    for (j = 0; j < numAlts; j++) {\n                        marks[alts[j]] = T;\n                    }\n                } else {\n                    letters[F] = T;\n                    for (j = 0; j < numAlts; j++) {\n                        letters[alts[j]] = T;\n                    }\n                    if (group === 'consonants' || group === 'other') {\n                        consonants[F] = T;\n\n                        for (j = 0; j < numAlts; j++) {\n                            consonants[alts[j]] = T;\n                        }\n                    }\n                }\n            }\n        }\n\n        return {consonants: consonants,\n            fromRoman: Sanscript.isRomanScheme(from),\n            letters: letters,\n            marks: marks,\n            maxTokenLength: Math.max.apply(Math, tokenLengths),\n            toRoman: Sanscript.isRomanScheme(to),\n            virama: toScheme.virama};\n    };\n\n    /**\n     * Transliterate from a romanized script.\n     *\n     * @param data     the string to transliterate\n     * @param map      map data generated from makeMap()\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    var transliterateRoman = function(data, map, options) {\n        var buf = [],\n            consonants = map.consonants,\n            dataLength = data.length,\n            hadConsonant = false,\n            letters = map.letters,\n            marks = map.marks,\n            maxTokenLength = map.maxTokenLength,\n            optSkipSGML = options.skip_sgml,\n            optSyncope = options.syncope,\n            tempLetter,\n            tempMark,\n            tokenBuffer = '',\n            toRoman = map.toRoman,\n            virama = map.virama;\n\n        // Transliteration state. It's controlled by these values:\n        // - `skippingSGML`: are we in SGML?\n        // - `toggledTrans`: are we in a toggled region?\n        //\n        // We combine these values into a single variable `skippingTrans`:\n        //\n        //     `skippingTrans` = skippingSGML || toggledTrans;\n        //\n        // If (and only if) this value is true, don't transliterate.\n        var skippingSGML = false,\n            skippingTrans = false,\n            toggledTrans = false;\n\n        for (var i = 0, L; (L = data.charAt(i)) || tokenBuffer; i++) {\n            // Fill the token buffer, if possible.\n            var difference = maxTokenLength - tokenBuffer.length;\n            if (difference > 0 && i < dataLength) {\n                tokenBuffer += L;\n                if (difference > 1) {\n                    continue;\n                }\n            }\n\n            // Match all token substrings to our map.\n            for (var j = 0; j < maxTokenLength; j++) {\n                var token = tokenBuffer.substr(0,maxTokenLength-j);\n\n                if (skippingSGML === true) {\n                    skippingSGML = (token !== '>');\n                } else if (token === '<') {\n                    skippingSGML = optSkipSGML;\n                } else if (token === '##') {\n                    toggledTrans = !toggledTrans;\n                    tokenBuffer = tokenBuffer.substr(2);\n                    break;\n                }\n                skippingTrans = skippingSGML || toggledTrans;\n                if ((tempLetter = letters[token]) !== undefined && !skippingTrans) {\n                    if (toRoman) {\n                        buf.push(tempLetter);\n                    } else {\n                        // Handle the implicit vowel. Ignore 'a' and force\n                        // vowels to appear as marks if we've just seen a\n                        // consonant.\n                        if (hadConsonant) {\n                            if ((tempMark = marks[token])) {\n                                buf.push(tempMark);\n                            } else if (token !== 'a') {\n                                buf.push(virama);\n                                buf.push(tempLetter);\n                            }\n                        } else {\n                            buf.push(tempLetter);\n                        }\n                        hadConsonant = token in consonants;\n                    }\n                    tokenBuffer = tokenBuffer.substr(maxTokenLength-j);\n                    break;\n                } else if (j === maxTokenLength - 1) {\n                    if (hadConsonant) {\n                        hadConsonant = false;\n                        if (!optSyncope) {\n                            buf.push(virama);\n                        }\n                    }\n                    buf.push(token);\n                    tokenBuffer = tokenBuffer.substr(1);\n                    // 'break' is redundant here, \"j == ...\" is true only on\n                    // the last iteration.\n                }\n            }\n        }\n        if (hadConsonant && !optSyncope) {\n            buf.push(virama);\n        }\n        return buf.join('');\n    };\n\n    /**\n     * Transliterate from a Brahmic script.\n     *\n     * @param data     the string to transliterate\n     * @param map      map data generated from makeMap()\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    var transliterateBrahmic = function(data, map, options) {\n        var buf = [],\n            consonants = map.consonants,\n            danglingHash = false,\n            hadRomanConsonant = false,\n            letters = map.letters,\n            marks = map.marks,\n            temp,\n            toRoman = map.toRoman,\n            skippingTrans = false;\n\n        for (var i = 0, L; (L = data.charAt(i)); i++) {\n            // Toggle transliteration state\n            if (L === '#') {\n                if (danglingHash) {\n                    skippingTrans = !skippingTrans;\n                    danglingHash = false;\n                } else {\n                    danglingHash = true;\n                }\n                if (hadRomanConsonant) {\n                    buf.push('a');\n                    hadRomanConsonant = false;\n                }\n                continue;\n            } else if (skippingTrans) {\n                buf.push(L);\n                continue;\n            }\n\n            if ((temp = marks[L]) !== undefined) {\n                buf.push(temp);\n                hadRomanConsonant = false;\n            } else {\n                if (danglingHash) {\n                    buf.push('#');\n                    danglingHash = false;\n                }\n                if (hadRomanConsonant) {\n                    buf.push('a');\n                    hadRomanConsonant = false;\n                }\n\n                // Push transliterated letter if possible. Otherwise, push\n                // the letter itself.\n                if ((temp = letters[L])) {\n                    buf.push(temp);\n                    hadRomanConsonant = toRoman && (L in consonants);\n                } else {\n                    buf.push(L);\n                }\n            }\n        }\n        if (hadRomanConsonant) {\n            buf.push('a');\n        }\n        return buf.join('');\n    };\n\n    /**\n     * Transliterate from one script to another.\n     *\n     * @param data     the string to transliterate\n     * @param from     the source script\n     * @param to       the destination script\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    Sanscript.t = function(data, from, to, options) {\n        options = options || {};\n        var cachedOptions = cache.options || {},\n            defaults = Sanscript.defaults,\n            hasPriorState = (cache.from === from && cache.to === to),\n            map;\n\n        // Here we simultaneously build up an `options` object and compare\n        // these options to the options from the last run.\n        for (var key in defaults) {\n            if (defaults.hasOwnProperty(key)) {\n                var value = defaults[key];\n                if (key in options) {\n                    value = options[key];\n                }\n                options[key] = value;\n\n                // This comparison method is not generalizable, but since these\n                // objects are associative arrays with identical keys and with\n                // values of known type, it works fine here.\n                if (value !== cachedOptions[key]) {\n                    hasPriorState = false;\n                }\n            }\n        }\n\n        if (hasPriorState) {\n            map = cache.map;\n        } else {\n            map = makeMap(from, to, options);\n            cache = {\n                from: from,\n                map: map,\n                options: options,\n                to: to};\n        }\n\n        // Easy way out for \"{\\m+}\", \"\\\", and \".h\".\n        if (from === 'itrans') {\n            data = data.replace(/\\{\\\\m\\+\\}/g, \".h.N\");\n            data = data.replace(/\\.h/g, '');\n            data = data.replace(/\\\\([^'`_]|$)/g, \"##$1##\");\n        }\n\n        var alldata = '';\n        if (map.fromRoman) {\n            alldata = transliterateRoman(data, map, options);\n        } else {\n            alldata = transliterateBrahmic(data, map, options);\n        }\n\n        // Fix any remaining quotations for Vedic Accents\n        if (to === 'devanagari' && options.enableSanskritVedicAccents === true) {\n            //alldata = alldata.replace('\\\\\"', \"\\u1CDA\").replace('\"', \"\\u1CDA\").replace('&quot;', \"\\u1CDA\");\n            alldata = alldata.replace(/\\\\?\"/g, \"\\u1CDA\");\n        } else if (! (to === \"itrans\" || to === \"iast\")) {\n            alldata = alldata.replace(/\\\\?\"/g, \"\");\n        }\n\n        // Enable Tamil Accents Support\n        if (to === 'tamil' && options.enableTamilPronounciation === true) {\n            alldata = alldata.replace(/(.)(²|³|⁴)(ா|ி|ீ|ு|ூ|ெ|ே|ை|ொ|ோ|ௌ|்)/g,\"$1$3$2\")\n        }\n        if (to === 'tamil' && options.enableTamilCharPositionFixes === true) {\n            alldata = alldata\n                .replace(/(^|\\s+)(த|ந்|தை)/g,\"$1ந$2\")\n                .replace(/([^\\s])ந/g, \"$1ன\")\n        }\n        return alldata;\n    };\n\n\n\nmodule.exports = {\n    Sanscript: Sanscript\n};\n","const parser = require('./fountain')\nconst Sanscript = require('./sanscript')\n// var concat = require('concat-stream')\n\nfunction transliterate(input, fromScheme, toScheme) {\n  var output = Sanscript.Sanscript.t(input, fromScheme, toScheme); //TODO\n  return output\n}\n\nfunction transform(dialog, dictionary, fromScheme, toScheme) {\n  const tokens = dialog.split(' ')\n  var output = '';\n  for(let i=0; i< tokens.length; i++) {\n    let token = tokens[i];\n    if (exclude(token.trim(), dictionary)) {\n      output = output + token + ' '\n    }\n    else {\n      output = output + transliterate(token, fromScheme, toScheme) + ' '\n    }\n  }\n  \n  return output;\n  \n}\n\nfunction exclude(word, dictionary) {\n  //remove trailing exclaimations  \n  let inDictionary =  dictionary[word.replace(/[-!?,.]*$/g,'').toLowerCase()]       \n  return inDictionary\n}\n\n\n// pass data to transliterate. It will call done when it is done.\nfunction literate(data, dictionary,fromScheme, toScheme, done) {  \n  \n  var result = [];\n  var output = {\n    write : function(line) {result.push(line)},\n    end: function() { done(result.join(\"\"))}\n  }\n  \n  // var output = concat((buffer) => done(buffer)); //create a stream\n\n  parser.parse(data.toString(), true, function (result) {\n    var tokens = result.tokens;\n    for(let i=0; i < tokens.length; i++) {\n      let token = tokens[i];\n      switch (token.type) {\n        case 'parenthetical': output.write(token.text+'\\n'); break;\n        case 'title': output.write('\\ntitle:' + token.text); break;\n        case 'credit': output.write('\\ncredit:' + token.text); break;\n        case 'author': output.write('\\nauthors:' + token.text); break;\n        case 'authors': output.write('\\nauthors:' + token.text); break;\n        case 'source': output.write('\\nsource:' + token.text); break;\n        case 'notes': output.write('\\nnotes:' + token.text); break;\n        case 'draft_date': output.write('\\ndraft_date:' + token.text); break;\n        case 'date': output.write('\\ndate:' + token.text); break;\n        case 'contact': output.write('\\ncontact:' + token.text); break;\n        case 'copyright': output.write('\\ncopyright:' + token.text); break;\n        case 'character': output.write(token.text+'\\n'); break;\n        case 'page_break':output.write(\"\\n\\n\"); break;\n        case 'line_break': output.write(\"\\n\\n\"); break;\n        case 'scene_heading':\n        case 'transition':\n        case 'action':  output.write('\\n'+token.text+'\\n'); break;\n        case 'dialogue_begin':\n        case 'dialogue_end': output.write(\"\\n\"); break;\n        case 'dual_dialogue_begin': break;\n        case 'dual_dialogue_end': break;\n        case 'dialogue':              \n            output.write(transform(token.text, dictionary, fromScheme, toScheme));\n            break;\n        case 'section': //TODO\n        default: \n          if (!token.text) { \n            console.log('unknown token'+ token); \n          } \n          // output.write(token.text); \n        break;\n    \n      }\n    }\n    output.end();  \n  })\n}\n\nmodule.exports = {\n  literate: literate\n}","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n"],"sourceRoot":""}